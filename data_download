"""
Script de t√©l√©chargement et pr√©paration des donn√©es pour cartographie Lyon
Base Permanente des √âquipements (BPE) + Contours IRIS
"""

import requests
import pandas as pd
import geopandas as gpd
from pathlib import Path
import zipfile
import io
from tqdm import tqdm
import logging

logger = logging.getLogger(__name__)

# Configuration
OUTPUT_DIR = Path("data_lyon")
OUTPUT_DIR.mkdir(exist_ok=True)

# D√©partements de la r√©gion lyonnaise
# 69 = Rh√¥ne/M√©tropole de Lyon, 01 = Ain, 42 = Loire, 38 = Is√®re (si vous voulez √©largir)
DEPARTEMENTS = ['69']  # Modifiez selon vos besoins

print("=" * 60)
print("T√âL√âCHARGEMENT DES DONN√âES - R√âGION LYONNAISE")
print("=" * 60)

# ============================================================================
# 1. T√âL√âCHARGER LA BPE
# ============================================================================
print("\nüì• √âtape 1/3 : T√©l√©chargement de la Base Permanente des √âquipements...")

# URL de la BPE 2023 (mill√©sime le plus r√©cent)
BPE_URL = "https://www.insee.fr/fr/statistiques/fichier/3568638/bpe23_ensemble_xy_csv.zip"

try:
    print(f"  ‚Üí T√©l√©chargement depuis l'INSEE...")
    response = requests.get(BPE_URL, stream=True)
    response.raise_for_status()
    
    # Taille du fichier
    total_size = int(response.headers.get('content-length', 0))
    
    # T√©l√©charger avec barre de progression
    content = io.BytesIO()
    with tqdm(total=total_size, unit='B', unit_scale=True, desc="  BPE") as pbar:
        for chunk in response.iter_content(chunk_size=8192):
            content.write(chunk)
            pbar.update(len(chunk))
    
    # D√©zipper
    print("  ‚Üí Extraction du fichier ZIP...")
    content.seek(0)
    with zipfile.ZipFile(content) as zip_file:
        # Trouver le fichier CSV
        csv_files = [f for f in zip_file.namelist() if f.endswith('.csv')]
        if csv_files:
            csv_file = csv_files[0]
            zip_file.extract(csv_file, OUTPUT_DIR)
            bpe_path = OUTPUT_DIR / csv_file
            print(f"  ‚úì BPE extraite : {bpe_path}")
        else:
            raise Exception("Aucun fichier CSV trouv√© dans le ZIP")
    
    # Charger et filtrer sur la r√©gion lyonnaise
    print("  ‚Üí Chargement et filtrage sur les d√©partements souhait√©s...")
    bpe_df = pd.read_csv(bpe_path, sep=';', dtype={'DEPCOM': str, 'DEP': str})
    
    # Filtrer sur les d√©partements
    bpe_lyon = bpe_df[bpe_df['DEP'].isin(DEPARTEMENTS)].copy()
    
    print(f"  ‚úì {len(bpe_lyon):,} √©quipements trouv√©s dans les d√©partements {', '.join(DEPARTEMENTS)}")
    
    # Sauvegarder la version filtr√©e
    bpe_lyon_path = OUTPUT_DIR / "bpe_lyon.csv"
    bpe_lyon.to_csv(bpe_lyon_path, index=False)
    print(f"  ‚úì Donn√©es sauvegard√©es : {bpe_lyon_path}")
    
except Exception as e:
    print(f"  ‚ùå Erreur lors du t√©l√©chargement de la BPE : {e}")
    raise

# ============================================================================
# 2. T√âL√âCHARGER LES CONTOURS IRIS
# ============================================================================
print("\nüì• √âtape 2/3 : T√©l√©chargement des contours IRIS...")

# URL du service WFS de l'IGN pour les IRIS
IRIS_WFS_URL = "https://wxs.ign.fr/statistiques/geoportail/wfs"

try:
    print("  ‚Üí R√©cup√©ration des IRIS via le service WFS de l'IGN...")
    
    # Param√®tres de la requ√™te WFS
    params = {
        'service': 'WFS',
        'version': '2.0.0',
        'request': 'GetFeature',
        'typename': 'CONTOURS-IRIS_FE:iris_ge',
        'outputFormat': 'application/json',
        'srsName': 'EPSG:4326'
    }
    
    response = requests.get(IRIS_WFS_URL, params=params, timeout=120)
    response.raise_for_status()
    
    # Charger en GeoDataFrame
    iris_gdf = gpd.read_file(io.BytesIO(response.content))
    
    print(f"  ‚úì {len(iris_gdf):,} IRIS charg√©s (France enti√®re)")
    
    # Filtrer sur les d√©partements
    iris_gdf['dep'] = iris_gdf['code_iris'].str[:2]
    iris_lyon = iris_gdf[iris_gdf['dep'].isin(DEPARTEMENTS)].copy()
    
    print(f"  ‚úì {len(iris_lyon):,} IRIS dans les d√©partements {', '.join(DEPARTEMENTS)}")
    
    # Sauvegarder en GeoJSON
    iris_lyon_path = OUTPUT_DIR / "iris_lyon.geojson"
    iris_lyon.to_file(iris_lyon_path, driver='GeoJSON')
    print(f"  ‚úì IRIS sauvegard√©s : {iris_lyon_path}")
    
except Exception as e:
    print(f"  ‚ùå Erreur lors du t√©l√©chargement des IRIS : {e}")
    print("  ‚ÑπÔ∏è  Tentative alternative avec le fichier de l'INSEE...")
    raise

# ============================================================================
# 3. CR√âER UN GEODATAFRAME DES √âQUIPEMENTS
# ============================================================================
print("\nüó∫Ô∏è  √âtape 3/3 : Cr√©ation du GeoDataFrame des √©quipements...")

try:
    # Charger la BPE filtr√©e
    bpe_lyon = pd.read_csv(OUTPUT_DIR / "bpe_lyon.csv")
    
    # Supprimer les lignes sans coordonn√©es
    bpe_lyon = bpe_lyon.dropna(subset=['LAMBERT_X', 'LAMBERT_Y'])
    
    print(f"  ‚Üí {len(bpe_lyon):,} √©quipements avec coordonn√©es")
    
    # Cr√©er un GeoDataFrame √† partir des coordonn√©es Lambert 93
    bpe_gdf = gpd.GeoDataFrame(
        bpe_lyon,
        geometry=gpd.points_from_xy(bpe_lyon.LAMBERT_X, bpe_lyon.LAMBERT_Y),
        crs='EPSG:2154'  # Lambert 93
    )
    
    # Reprojeter en WGS84 pour la compatibilit√© avec les cartes web
    bpe_gdf = bpe_gdf.to_crs('EPSG:4326')
    
    # Sauvegarder en GeoJSON
    bpe_geo_path = OUTPUT_DIR / "bpe_lyon.geojson"
    bpe_gdf.to_file(bpe_geo_path, driver='GeoJSON')
    print(f"  ‚úì GeoDataFrame sauvegard√© : {bpe_geo_path}")
    
except Exception as e:
    print(f"  ‚ùå Erreur lors de la cr√©ation du GeoDataFrame : {e}")
    raise

# ============================================================================
# R√âSUM√â
# ============================================================================
print("\n" + "=" * 60)
print("‚úÖ T√âL√âCHARGEMENT TERMIN√â !")
print("=" * 60)
print(f"\nüìÅ Fichiers cr√©√©s dans le dossier '{OUTPUT_DIR}' :")
print(f"  ‚Ä¢ bpe_lyon.csv         - BPE format CSV")
print(f"  ‚Ä¢ bpe_lyon.geojson     - BPE format g√©ographique")
print(f"  ‚Ä¢ iris_lyon.geojson    - Contours IRIS")

print("\nüìä Statistiques :")
print(f"  ‚Ä¢ √âquipements : {len(bpe_lyon):,}")
print(f"  ‚Ä¢ IRIS : {len(iris_lyon):,}")

# Afficher quelques types d'√©quipements
print("\nüè¢ Principaux types d'√©quipements :")
top_types = bpe_lyon['TYPEQU'].value_counts().head(10)
for type_eq, count in top_types.items():
    print(f"  ‚Ä¢ {type_eq} : {count:,}")

print("\nüéØ Prochaine √©tape : cr√©er la carte interactive avec ces donn√©es !")
print("=" * 60)